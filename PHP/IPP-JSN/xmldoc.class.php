<?php

#JSN:xlukac09

  # jsn.php     Assigment in IPP course
  # Author:     Jakub Lukac
  # E-mail:     xlukac09@stud.fit.vutbr.cz
  # Date:       09-03-2016
  # Testing:    PHP 5.5.9
  #             PHP 5.3.3 (merlin)

  # This class extend standart class DOMDocument, it adds several properties,
  # which could be modified and affect the format of XML output.
  # XML output is generated by xml_encode method.
  class XMLDocument extends DOMDocument
  {

    # properties

    public $subst             = "-";
    public $gen_header        = true;
    public $root_element      = false;
    public $array_name        = "array";
    public $item_name         = "item";
    public $text_str          = false;
    public $text_num          = false;
    public $text_lit          = false;
    public $replace_entities  = true;
    public $add_arr_size      = false;
    public $add_arr_index     = false;
    public $arr_index         = 1;
    public $use_padding       = false;

    # methods

    # create a document object and set nice output format
    function __construct ($version, $encoding) {
      parent::__construct($version, $encoding);
      // nice output
      $this->formatOutput = true;
    }

    # first substitute unsupported characters in $value and then validate it
    # if $value is valid, create a new element object otherwise exit
    public function createElement ($name, $value = NULL) {
      // substitute unsupported characters
      $subst_pattern = "/(^[\d-\.]|[^\pL\d-_\.])/u";
      $name = preg_replace($subst_pattern, $this->subst, $name);
      if ($name == NULL) {
        fwrite(STDERR, "Cannot replace unsupported characters" . PHP_EOL);
        exit(100);
      }

      // check if a string is valid now
      if (!$this->is_valid_elem_name($name)) {
        fwrite(STDERR, "Invalid element name after substitution: " . $name . PHP_EOL);
        exit(51);
      }

      return parent::createElement($name, $value);
    }

    # validate element name
    public function is_valid_elem_name ($name)
    {
      if ($name === "") {
        // empty string as name - _empty_
        return true;
      }
      $regex_pattern = "/\A[\pL_][\pL\d-_\.]*\z/u";
      return preg_match($regex_pattern, $name);
    }

    # convert an object to valid DOMDocument tree
    # returns the encoded string
    public function xml_encode ($data_object)
    {
      $root = $this->add_root();

      if (is_object($data_object)) {
        // add subelemnts
        $this->add_elements($root, $data_object);
      } else {  // is array
        // add array
        $this->add_array($root, $data_object);
      }

      # replace special characters with entity references
      if ($this->replace_entities) {
        return htmlspecialchars_decode($this->__toString());
      } else {
        // entity references are used by default
        return $this->__toString();
      }
    }

    # optionally add root to the tree
    private function add_root ()
    {
      if ($this->root_element) {
        // create a root element
        $root = $this->createElement($this->root_element);
        // append it to the document itself
        $root = $this->appendChild($root);
        return $root;
      }
      return $this;
    }

    # iterate thought object and add an elements to the tree
    private function add_elements ($actual_root, $data_object)
    {
      foreach($data_object as $key => $value) {
        # tag
        $elem = $this->createElement($key);
        // append it to the actual root element
        $elem = $actual_root->appendChild($elem);

        # value
        if (is_object($value)) {
          // add subelemnts
          $this->add_elements($elem, $value);
        } elseif (is_array($value)) {
          // add array
          $this->add_array($elem, $value);
        } else {
          // add value
          $this->add_value($elem, $key, $value);
        }
      }
    }

    # add an array element to the tree
    private function add_array ($actual_root, $data_array)
    {
      // create an array element
      $array_elem = $this->createElement($this->array_name);
      // append it to the actual root element
      $array_elem = $actual_root->appendChild($array_elem);
      // add size
      if ($this->add_arr_size) {
        $array_elem->setAttribute("size", count($data_array));
      }

      $max_index_width = strlen($this->arr_index + count($data_array) - 1);

      // add subelemnts - items
      foreach ($data_array as $key => $value) {
        $this->add_item($array_elem, $key, $max_index_width, $value);
      }
    }

    # add an item element to the tree
    private function add_item ($array, $rel_index, $max_index_width, $value)
    {
      // create an item element
      $item_elem = $this->createElement($this->item_name);
      // append it to the array
      $item_elem = $array->appendChild($item_elem);
      // add index
      if ($this->add_arr_index) {
        if ($this->use_padding) {
          $index = str_pad($this->arr_index + $rel_index, $max_index_width, "0", STR_PAD_LEFT);
          $item_elem->setAttribute("index", $index);
        } else {
          $item_elem->setAttribute("index", $this->arr_index + $rel_index);
        }
      }

      if (is_object($value)) {
        // add subelemnts
        $this->add_elements($item_elem, $value);
      } elseif (is_array($value)) {
        // add array
        $this->add_array($item_elem, $value);
      } else {
        // add value
        $this->add_value($item_elem, $this->item_name, $value);
      }
    }

    # add a value to the element
    private function add_value($element, $tag_name, $value)
    {
      $use_text = false;  // use text node instead of atribute

      // normalize $value, create a node with it
      if (is_string($value)) {
        $use_text = $this->text_str;
        $text = $this->createTextNode($value);
      } elseif (is_numeric($value)) {
        $value = intval(floor($value));
        $use_text = $this->text_num;
        $text = $this->createTextNode($value);
      } elseif (is_bool($value)) {
        $value = ($value) ? "true" : "false";
        $use_text = $this->text_lit;
        $text = $this->createElement($value);
      } elseif (is_null($value)) {
        $value = "null";
        $use_text = $this->text_lit;
        $text = $this->createElement($value);
      }

      if ($use_text) {
        $text = $element->appendChild($text);
      } else {
        $element->setAttribute("value", $value);
      }
    }

    # convert the DOMDocument tree to XML string
    # returns the converted string
    public function __toString ()
    {
      if ($this->gen_header) {
        // with XML declaration
        return $this->saveXML();
      } else {
        // without XML declaration
        $ret_str = "";
        foreach ($this->childNodes as $node) {
          $ret_str .= $this->saveXML($node) . PHP_EOL;
        }
        return $ret_str;
      }
    }

  }

?>
